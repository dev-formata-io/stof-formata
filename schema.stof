//
// Copyright 2024 Formata, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//


root Formata: {
    /**
     * Schema field operation type.
     * Each operation will be applied in an order of the user's choosing to a field.
     */
    type SchemaOp {
        /// Attribute value from creating this operation.
        value: unknown = null;

        /// Perform this operation on the field, returning true if the field is still valid
        /// and should be kept. Returning false will result in the field being removed and the schema invalid.
        fn operate(target: obj, field_name: str): bool {
            return true;
        }
        
        /// Destroy this operation and all of it's data!
        fn destroy() {
            drop self;
        }
    }

    /**
     * Formata Schema Type.
     * Schemas outline the fields that should exist on an object, once applied.
     */
    type Schema {
        /**
         * Apply this Schema to an object.
         * By default, this schema applies to itself...
         */
        fn apply(target: obj = self): bool {
            let valid = true;
            for (field in self.keys()) {
                if (!self.apply_field(target, field)) valid = false;
            }
            return valid;
        }

        // Apply this schema to an individual field.
        fn apply_field(target: obj, field: str, operations: Box<vec> = null): bool {
            let valid = true;
            try {
                let created = false;
                if (operations == null) {
                    created = true;
                    operations = Formata.Schema.createFieldOperations(target, self, field);
                }
                for (op in operations) {
                    if (!op.operate(target, field)) {
                        valid = false;
                        break;
                    }
                    if (created) op.destroy();
                }
            } catch {
                valid = false;
            }
            if (!valid) {
                target.removeField(field, true);
            } else {
                let value = target.at(field);

                // If this value is a sub-schema, apply it also
                let type_name = typeof value;
                if (type_name == 'obj' || type_name == 'Box<obj>') {
                    let self_value = self.at(field);
                    type_name = typeof self_value;
                    if (self_value != null && (type_name == 'obj' || type_name == 'Box<obj>') && self_value.instanceOf('Schema')) {
                        valid = self_value.apply(value);
                    }
                    if (!valid) { // sub-schema was invalid, so remove this object!
                        target.removeField(field, true);
                    }
                }
            }
            return valid;
        }
    }

    /**
     * Schema Scope, used for helper functions, op types, etc..
     */
    Schema: {
        // Allow access for a field in the schema?
        // Uses a 'self.value' for the attribute value.
        // Signatures:
        // - #[access(true | false)]
        // - #[access((target: obj): bool => true)]
        type Access extends SchemaOp {
            /// Perform this operation on the field, returning true if the field is still valid
            /// and should be kept. Returning false will result in the field being removed and the schema invalid.
            fn operate(target: obj, field: str): bool {
                let attr = self.value;
                switch (typeof attr) {
                    case 'fn': {
                        try {
                            if (!attr.call(target)) return false;
                        } catch {
                            return false;
                        }
                    }
                    default: {
                        if (!attr) return false;
                    }
                }
                return true;
            }
        }

        // Validate this field's value.
        // Uses a 'self.value' for the attribute value in which to validate with.
        // Signatures:
        // - #[validate(value: unknown)]                      // valid if field value is equal to value
        // - #[validate((value: unknown): unknown => value)]  // sets a validated value
        // - #[validate((value: unknown): bool => true)]      // keeps or removes the value (return true if valid)
        // - #[validate([...])]                               // valid if array contains the value
        // - #[validate(set(...))]                            // valid if set contains the value
        // - #[validate(map([(unknown, (): bool => true)]))]  // map a value to a valid function
        // - #[validate(map([(unknown, (): unknown => '')]))] // map a value to a different value
        type Validate extends SchemaOp {
            /// Perform this operation on the field, returning true if the field is still valid
            /// and should be kept. Returning false will result in the field being removed and the schema invalid.
            fn operate(target: obj, field: str): bool {
                let attr = self.value;
                let field_value = target.at(field);
                if (field_value == null) return true; // this op only validates, not excludes

                switch (typeof attr) {
                    case 'fn': {
                        // validating this value with a function
                        // (value: unknown): unknown => value // sets the value
                        // (value: unknown): bool => true     // keeps or removes the value
                        if (attr.returnType() == 'bool') {
                            if (!attr.call(field_value)) return false;
                        } else {
                            target.set(field, attr.call(field_value));
                        }
                    }
                    case 'vec': {
                        let items = set(attr);
                        if (!items.contains(field_value)) return false;
                    }
                    case 'set': {
                        if (!attr.contains(field_value)) return false;
                    }
                    case 'map': {
                        // validating this value with a map
                        let map_val = attr.get(field_value);
                        switch (typeof map_val) {
                            case 'fn': {
                                if (map_val.returnType() == 'bool') {
                                    if (!map_val.call()) return false;
                                } else {
                                    target.set(field, map_val.call());
                                }
                            }
                            default: {
                                return false;
                            }
                        }
                    }
                    default: {
                        if (attr != field_value) return false;
                    }
                }
                return true;
            }
        }

        // Search for this value on the target if the value doesn't already exist.
        // Uses a 'self.value' for the attribute value and a 'self.optional' for validity if not found.
        // Signatures:
        // - #[search]           // look for the closest field with this name on the target (or key 'all')
        // - #[search('up')]     // look for the closest field on a parent (or parents children) with this name
        // - #[search('uponly')] // look for the closest field on a parent (no parent children) with this name
        // - #[search('down')]   // look for the closest field on a child with this name (first one seen)
        // - #[search(vec())]    // try searching for these field names, in-order, anywhere in the target
        // - #[search(map())]    // try searching for these field names, (alphabetical order), with a strategy: {'all', 'up', 'uponly', 'down'}
        type Search extends SchemaOp {
            /// Perform this operation on the field, returning true if the field is still valid
            /// and should be kept. Returning false will result in the field being removed and the schema invalid.
            fn operate(target: obj, field: str): bool {
                let field_value = target.at(field);
                if (field_value != null) return true; // value already exists
                let attr = self.value;
                switch (typeof attr) {
                    case 'null' |
                    case 'str': {
                        let res = null;
                        if (attr == 'up') res = target.searchUp(field, true, [self]);
                        else if (attr == 'uponly') res = target.searchUp(field, false, [self]);
                        else if (attr == 'down') res = target.searchDown(field, 0, [self]);
                        else res = target.search(field, true, [self]);

                        if (res != null) {
                            target.set(field, res[0]);
                        } else if (self.optional) {
                            return true; // didn't find a value, but that's okay, it is not required...
                        } else {
                            return false; // didn't find a value, and that's a problem!
                        }
                        return true;
                    }
                    case 'vec': {
                        let res = null;
                        for (other_name in attr) {
                            res = target.search(other_name, true, [self]);
                            if (res != null) break;
                        }
                        if (res != null) {
                            target.set(field, res[0]);
                        } else if (self.optional) {
                            return true; // didn't find a value, but that's okay, it is not required...
                        } else {
                            return false; // didn't find a value, and that's an issue
                        }
                        return true;
                    }
                    case 'map': {
                        let other_name = null;
                        let strategy = null;
                        let res = null;
                        for (item in attr) {
                            other_name = item[0];
                            strategy = item[1];
                            
                            if (strategy == 'up') res = target.searchUp(other_name, true, [self]);
                            else if (strategy == 'uponly') res = target.searchUp(other_name, false, [self]);
                            else if (strategy == 'down') res = target.searchDown(other_name, 0, [self]);
                            else res = target.search(other_name, true, [self]);

                            if (res != null) break;
                        }
                        if (res != null) {
                            target.set(field, res[0]);
                        } else if (self.optional) {
                            return true; // didn't find a value, but that's okay, it is not required...
                        } else {
                            return false; // didn't find a value, and that's an issue
                        }
                        return true;
                    }
                    default: {
                        return false; // not valid
                    }
                }
            }
        }

        // Exclude this field if found. Removes the field, but retains validity.
        // Uses a 'self.value' for the attribute value to check for field exlusion.
        // Signatures:
        // - #[exclude]                                  // always exclude this field
        // - #[exclude((value: unknown): bool => true)]  // return true if the field should be excluded
        type Exclude extends SchemaOp {
            /// Perform this operation on the field, returning true if the field is still valid
            /// and should be kept. Returning false will result in the field being removed and the schema invalid.
            fn operate(target: obj, field: str): bool {
                let attr = self.value;
                switch (typeof attr) {
                    case 'fn': {
                        try {
                            if (attr.call(target.at(field))) target.removeField(field, true);
                        } catch {
                            target.removeField(field, true);
                        }
                    }
                    default: target.removeField(field, true);
                }
                return true;
            }
        }

        // Requires this field to be validated by additional schemas to be valid
        // Uses a 'self.value' for the attribute value pointing to other schema(s) to use.
        // Signatures:
        // - #[schema(other: obj)]  // uses 'other' as an additional schema to validate this field with
        // - #[schemas(vec())]      // uses each object in the vec as another schema - all must be valid
        // - #[schemas(set())]      // uses each object in the set as another schema - one must be valid
        type AdditionalSchema extends SchemaOp {
            /// Perform this operation on the field, returning true if the field is still valid
            /// and should be kept. Returning false will result in the field being removed and the schema invalid.
            fn operate(target: obj, field: str): bool {
                let attr = self.value;
                try {
                    switch (typeof attr) {
                        case 'obj': {
                            return attr.apply(target);
                        }
                        case 'vec': {
                            // AND - all schemas in the vec must be valid
                            for (schema in attr) {
                                if (!schema.apply(target)) return false;
                            }
                        }
                        case 'set': {
                            // OR - just one schema must be valid
                            for (schema in attr) {
                                if (schema.apply(target)) return true;
                            }
                            return false;
                        }
                        default: return false;
                    }
                } catch {
                    return false;
                }
                return true;
            }
        }

        // Applies the schema value as a default value if the field doesn't exist.
        // Uses 'self.default' as the default value to apply.
        // Signature: #[default]
        type Default extends SchemaOp {
            /// Perform this operation on the field, returning true if the field is still valid
            /// and should be kept. Returning false will result in the field being removed and the schema invalid.
            fn operate(target: obj, field: str): bool {
                let field_value = target.at(field);
                if (field_value == null) {
                    let default_value = self.default;
                    if (default_value != null) {
                        target.set(field, default_value);
                        return true;
                    }
                    return false;
                }
                return true;
            }
        }

        // Requires the target to have provided the value.
        // Signature: #[required]
        type Required extends SchemaOp {
            /// Perform this operation on the field, returning true if the field is still valid
            /// and should be kept. Returning false will result in the field being removed and the schema invalid.
            fn operate(target: obj, field: str): bool {
                return target.at(field) != null;
            }
        }

        // Requires a field to be of a specific type.
        // Uses 'self.value' as the attribute value for typeof check.
        // Signature: #[typeof('str')]
        type TypeOf extends SchemaOp {
            /// Perform this operation on the field, returning true if the field is still valid
            /// and should be kept. Returning false will result in the field being removed and the schema invalid.
            fn operate(target: obj, field: str): bool {
                let field_value = target.at(field);
                if (field_value == null) return true; // only checks type, not existence
                if ((typeof field_value) == self.value) return true;
                return false;
            }
        }

        // Expand a collection, applying operations to each value.
        // Uses 'self.operations' as the vector of operations to perform per value in the collection.
        // Signature: #[expand]
        type Expand extends SchemaOp {
            /// Perform this operation on the field, returning true if the field is still valid
            /// and should be kept. Returning false will result in the field being removed and the schema invalid.
            fn operate(target: obj, field: str): bool {
                let collection = target.at(field);
                let operations = box(self.operations);
                if ((typename operations) != "vec" || operations.empty()) return true;

                let valid = true;
                let tmp = new {}; // temp target object for each value
                let sc = new Schema {}; // temp schema for each value
                try {
                    switch (typeof collection) {
                        case 'vec': {
                            let to_remove = [];
                            let tgt = null;
                            let objval = false;
                            for (val in collection) {
                                if ((typeof val) == "obj" || (typeof val) == "Box<obj>") {
                                    tgt = val;
                                    objval = true;
                                } else {
                                    tmp.set(field, val);
                                    tgt = tmp;
                                }
                                
                                sc.set(field, val);
                                if (!sc.apply_field(tgt, field, operations)) {
                                    valid = false;
                                    to_remove.push(index);
                                } else if (!objval) {
                                    collection.set(index, tgt.at(field));
                                }
                            }
                            to_remove.reverse();
                            for (i in to_remove) {
                                collection.pop(i);
                            }
                            target.set(field, collection);
                        }
                        case 'set': {
                            let to_remove = [];
                            let to_insert = [];
                            let tgt = null;
                            let objval = false;
                            for (val in collection) {
                                if ((typeof val) == "obj" || (typeof val) == "Box<obj>") {
                                    tgt = val;
                                    objval = true;
                                } else {
                                    tmp.set(field, val);
                                    tgt = tmp;
                                }
                                
                                if (!sc.apply_field(tgt, field, operations)) {
                                    valid = false;
                                    to_remove.push(val);
                                } else if (!objval) {
                                    to_insert.push(tgt.at(field));
                                }
                            }
                            for (val in to_remove) collection.remove(val);
                            for (val in to_insert) collection.insert(val);
                            target.set(field, collection);
                        }
                        default: {
                            throw('collection not supported for #[expand] operation');
                        }
                    }
                } catch {
                    valid = false;
                }
                drop tmp;
                drop sc;
                return valid;
            }

            fn destroy() {
                try {
                    for (SchemaOp op in self.operations) {
                        op.destroy();
                    }
                } catch {
                    // nada..
                }
                self.SchemaOp::destroy();
            }
        }

        // Create operations for a field from it's attributes.
        fn createFieldOperations(target: obj, schema: obj, field: str): Box<vec> {
            let operations = box(vec());
            let attributes = schema.attributes(field).or(map());
            let order = attributes.keys();

            let custom_order = attributes.remove("order");
            if (custom_order != null) {
                if ((typename custom_order) == "vec") {
                    custom_order.retain((val: unknown): bool => attributes.contains(val));
                    if (custom_order.len() != order.len()) {
                        for (key in custom_order) order.removeAll(key);
                        custom_order.append(order);
                    }
                    order = custom_order;
                }
            }

            let optional_search = false;
            let expand_operations = false;
            for (key in order) {
                switch (key) {
                    // #[ignore] ignores this field in the schema by returning valid always.
                    case 'ignore': {
                        return operations; // just return valid (or current ops)
                    }
                    // #[optional] ignores this field in the schema if a value doesn't exist for it on the target object.
                    case 'optional': {
                        if (target.at(field) == null) {
                            return operations; // if no field value, then just return valid (or current ops)
                        }
                    }
                    // Determins whether the target should have access to this field.
                    case 'access': {
                        operations.push(new Access {
                            value: attributes.get(key);
                        });
                    }
                    // Sets the search to optional, meaning if the search doesn't find anything, the field will still be valid.
                    case 'optionalSearch': {
                        optional_search = true;
                    }
                    // Search for a value on the target if one doesn't already exist.
                    case 'search': {
                        operations.push(new Search {
                            value: attributes.get(key);
                            optional: optional_search;
                        });
                    }
                    // Validate this field's value.
                    case 'validate': {
                        operations.push(new Validate {
                            value: attributes.get(key);
                        });
                    }
                    // Additional schema(s) to use for this field.
                    case 'schemas' |
                    case 'schema': {
                        operations.push(new AdditionalSchema {
                            value: attributes.get(key);
                        });
                    }
                    // Exclude this field when seen.
                    case 'exclude': {
                        operations.push(new Exclude {
                            value: attributes.get(key);
                        });
                    }
                    // Expand these operations over a collection.
                    case 'expand': {
                        expand_operations = true;
                    }
                    // Apply the schema value as a default value if doesn't exist.
                    case 'default': {
                        operations.push(new Default {
                            default: schema.at(field);
                        });
                    }
                    // Mark this field as required to be provided by the target.
                    case 'required': {
                        operations.push(new Required {});
                    }
                    // Require the field type to be a specific typeof value.
                    case 'typeof': {
                        operations.push(new TypeOf {
                            value: attributes.get(key);
                        });
                    }
                }
            }
            if (expand_operations) {
                return box(vec(new Expand {
                    operations: operations;
                }));
            }
            return operations;
        }
    }
}
